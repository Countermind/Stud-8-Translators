#ifndef __PARSE_TREE_H__
#define __PARSE_TREE_H__

/**
 * parse-tree.h
 *   Структуры данных для дерева разбора.
 *
 */

// +-------------+
// | Комментарии |
// +-------------+

/*
  Мы представляем узлы с использованием традиционной для язык C стратегии.
  Каждый объект начинается с целого числа - типа узла. Обычно они генерируются
  случайным образом, однако, т.к. у нас очень мало типов, то используются
  предопределенные числа. Такая стратегия должна бы немного сложнее
  для реализации проверки типов. Это вероятно будет сделано в будущих версиях.
  Наследование поддерживается через включение структур.  Поскольку стандарт C
  говорит, что элементы структур упорядочены, то указывая элемент суперкласса
  первым, мы гарантируем, что его поля будут содержаться внутри.
 */


#include <stdio.h>
#include "attribute.h"


/**
 * У абстрактных узлов есть тип (для объектов), символ (терминал
 * или нетерминал) и набор атрибутов.
 */        
extern int TYPE_NODE;
typedef struct Node
{
    int type;
    int symbol;
    AttributeSet* attributes;
} Node;

/**
 * У узлов, содержащих терминалы/лексемы нет дополнительной информации.
 * Тем не менее, обеспечивается отдельный тип для ясности.
 */
extern int TYPE_TNODE;
typedef struct TNode
{
    Node parent;
} TNode;

/**
 * Узлы, содержащие нетерминалы, могут иметь набор прямых потомков.
 */
extern int TYPE_NNODE;
typedef struct NNode
{
    Node parent;
    int arity;          // Количество прямых потомков
    Node** children;    // Поддеревья
} NNode;


// +-------------------+
// | Прототипы функций |
// +-------------------+

/**
 * Освобождение памяти, занятой под дерево разбора.
 */
void FreeTree(Node* tree);

/**
 * Получение арности корня дерева.
 */
int GetNodeArity(Node* tree);

/*
 * Получение i-го поддерева заданного дерева.
 */
Node* GetNodeChild(Node* tree, int i);

/**
 * Является ли узел нетерминалом (NNode).
 */
int IsNonterminalNode(Node* tree);

/**
 * Является ли узел терминалом (TNode).
 */
int IsTerminalNode(Node* tree);

/**
 * Создает новый нетерминальный узел, который содержит заданную информацию.
 * Возвращает узел в случае успеха и NULL в противном случае.
 */
Node* CreateNonterminalNode(int nonterm, int arity, AttributeSet* attributes);

/**
 * Создает новый терминальный узел, который содержит заданную информацию.
 * Возвращает узел в случае успеха и NULL в противном случае.
 */
Node* CreateTerminalNode(int term, AttributeSet* attributes);

/** 
 * Печатает дерево в выходной поток.
 */
void PrintTree(FILE* stream, Node* node);

/**
 * Задает i-го потомка узла дерева. 
 * Возвращает 1 в случае успеха и 0 в противном случае.
 */
int SetNodeChild(Node* node, int i, Node* child);

#endif